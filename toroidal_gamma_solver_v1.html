<!DOCTYPE html>
<canvas id="c"></canvas>
<style>
    html,
    body,
    canvas {
        background-color: black;
    }
</style>
<script>
    c = document.getElementById("c");
    ctx = c.getContext("2d");
    cell_width = 50;
    c.width = cell_width * 16;
    c.height = cell_width * 16;

    const draw_centers = function (lattice) {
        for (let i = 0; i < 16; i++) {
            for (let j = 0; j < 16; j++) {
                ctx.fillStyle = lattice[16 * j + i] !== -1 ? "green" : "maroon";
                ctx.beginPath();
                ctx.arc(
                    (i + 0.5) * cell_width,
                    (j + 0.5) * cell_width,
                    cell_width / 4,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            }
        }
    }

    const draw_arms = function (lattice) {
        ctx.strokeStyle = "white";
        ctx.lineWidth = cell_width / 16;
        for (let i = 0; i < 16; i++) {
            for (let j = 0; j < 16; j++) {
                const num = lattice[i + 16 * j];
                if (num === -1) continue;
                for (let k = 0; k < 8; k++) {
                    ctx.beginPath();
                    ctx.moveTo((i + 0.5) * cell_width, (j + 0.5) * cell_width);
                    if ((num >> k) & 1) {
                        switch (k) {
                            case 0:
                                ctx.lineTo((i + 1) * cell_width, j * cell_width);
                                break;
                            case 1:
                                ctx.lineTo((i + 1) * cell_width, (j + 0.5) * cell_width);
                                break;
                            case 2:
                                ctx.lineTo((i + 1) * cell_width, (j + 1) * cell_width);
                                break;
                            case 3:
                                ctx.lineTo((i + 0.5) * cell_width, (j + 1) * cell_width);
                                break;
                            case 4:
                                ctx.lineTo(i * cell_width, (j + 1) * cell_width);
                                break;
                            case 5:
                                ctx.lineTo(i * cell_width, (j + 0.5) * cell_width);
                                break;
                            case 6:
                                ctx.lineTo(i * cell_width, j * cell_width);
                                break;
                            case 7:
                                ctx.lineTo((i + 0.5) * cell_width, j * cell_width);
                                break;
                        }
                    }
                    ctx.stroke();
                }
            }
        }
    }

    const draw_numbers = function (lattice) {
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.font = "15px sanserif";
        ctx.textAlign = "center";
        for (let i = 0; i < 16; i++) {
            for (let j = 0; j < 16; j++) {
                let number = lattice[i + j * 16];
                if (number !== -1)
                    ctx.strokeText(number, (i + 0.5) * cell_width, (j + 0.6) * cell_width);
            }
        }
    }

    const draw_lattice = function (lattice) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, c.width, c.height);
        draw_arms(lattice);
        draw_centers(lattice);
        draw_numbers(lattice);
    }

    const move_at = function (idx, dir) {
        if (dir === "N") 
            return is_edge(idx, "top") ? idx + 240 : idx - 16;
        if (dir === "E") 
            return is_edge(idx, "right") ? idx - 15 : idx + 1;
        if (dir === "S") 
            return is_edge(idx, "bottom") ? idx - 240 : idx + 16;
        if (dir === "W") 
            return is_edge(idx, "left") ? idx + 15 : idx - 1;
        if (dir === "NE") {
            if (idx === 15) return 240;
            if (is_edge(idx, "top")) return idx + 241;
            if (is_edge(idx, "right")) return idx - 31;
            return idx - 15;
        }
        if (dir === "SE") {
            if (idx === 255) return 0;
            if (is_edge(idx, "bottom")) return idx - 239;
            if (is_edge(idx, "right")) return idx + 1;
            return idx + 17;
        }
        if (dir === "SW") {
            if (idx === 240) return 15;
            if (is_edge(idx, "bottom")) return idx - 241;
            if (is_edge(idx, "left")) return idx + 31;
            return idx + 15;
        }
        if (dir === "NW") {
            if (idx === 0) return 255;
            if (is_edge(idx, "top")) return idx + 239;
            if (is_edge(idx, "left")) return idx - 1;
            return idx - 17;
        }
    }

    const filter_by_position = function (options, position, except) {
        return options.map((arr, key) => key === except ? arr : arr.filter(i => i != position));
    }

    // makes sure future neighbors are only considered when they have matching connections
    const filter_neighbors_orthogonal = function (lattice, options, number, pos) {
        // shallow copy of options arrays
        let options_loc = options.map(arr => [...arr]);
        
        if (number & 0b10000000)
            options_loc = options_loc.map((arr, n) => n & 0b00001000 ? arr : arr.filter(x => x !== move_at(pos, "N")));
        else
            options_loc = options_loc.map((arr, n) => n & 0b00001000 ? arr.filter(x => x !== move_at(pos, "N")) : arr);
        if (number & 0b00000010)
            options_loc = options_loc.map((arr, n) => n & 0b00100000 ? arr : arr.filter(x => x !== move_at(pos, "E")));
        else
            options_loc = options_loc.map((arr, n) => n & 0b00100000 ? arr.filter(x => x !== move_at(pos, "E")) : arr);
        if (number & 0b00001000)
            options_loc = options_loc.map((arr, n) => n & 0b10000000 ? arr : arr.filter(x => x !== move_at(pos, "S")));
        else
            options_loc = options_loc.map((arr, n) => n & 0b10000000 ? arr.filter(x => x !== move_at(pos, "S")) : arr);
        if (number & 0b00100000)
            options_loc = options_loc.map((arr, n) => n & 0b00000010 ? arr : arr.filter(x => x !== move_at(pos, "W")));
        else
            options_loc = options_loc.map((arr, n) => n & 0b00000010 ? arr.filter(x => x !== move_at(pos, "W")) : arr);

        return options_loc;
    };

    // makes sure gamma condition is met and every diagonal slot has exactly one diagonal
    const filter_single_diagonal = function (lattice, options, number, pos) {
        // shallow copy of options arrays
        let options_loc = options.map(arr => [...arr]);

        if (number & 0b00000001) {
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr : arr.filter(x => x !== move_at(pos, "NE")));
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr.filter(x => x !== move_at(pos, "N")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr.filter(x => x !== move_at(pos, "E")) : arr);
        } else {
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr.filter(x => x !== move_at(pos, "NE")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr : arr.filter(x => x !== move_at(pos, "N")));
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr : arr.filter(x => x !== move_at(pos, "E")));
        }
        if (number & 0b00000100) {
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr : arr.filter(x => x !== move_at(pos, "SE")));
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr.filter(x => x !== move_at(pos, "S")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr.filter(x => x !== move_at(pos, "E")) : arr);
        }
        else {
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr.filter(x => x !== move_at(pos, "SE")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr : arr.filter(x => x !== move_at(pos, "S")));
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr : arr.filter(x => x !== move_at(pos, "E")));
        }
        if (number & 0b00010000) {
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr : arr.filter(x => x !== move_at(pos, "SW")));
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr.filter(x => x !== move_at(pos, "S")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr.filter(x => x !== move_at(pos, "W")) : arr);
        } else {
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr.filter(x => x !== move_at(pos, "SW")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b01000000 ? arr : arr.filter(x => x !== move_at(pos, "S")));
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr : arr.filter(x => x !== move_at(pos, "W")));
        }
        if (number & 0b01000000) {
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr : arr.filter(x => x !== move_at(pos, "NW")));
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr.filter(x => x !== move_at(pos, "N")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr.filter(x => x !== move_at(pos, "W")) : arr);
        } else {
            options_loc = options_loc.map((arr, n) => n & 0b00000100 ? arr.filter(x => x !== move_at(pos, "NW")) : arr);
            options_loc = options_loc.map((arr, n) => n & 0b00010000 ? arr : arr.filter(x => x !== move_at(pos, "N")));
            options_loc = options_loc.map((arr, n) => n & 0b00000001 ? arr : arr.filter(x => x !== move_at(pos, "W")));
        }

        return options_loc;
    }

    const filter_search_space = function (lattice, options, number, position) {
        let options_loc = [...options].map(x => [...x]);

        // first, filter out all options with the same position
        options_loc = filter_by_position(options_loc, position, number);

        // second, filter neighbors by orthogonal connections
        options_loc = filter_neighbors_orthogonal(lattice, options_loc, number, position);

        // third, filter by gamma conditions and diagonals
        options_loc = filter_single_diagonal(lattice, options_loc, number, position);

        return options_loc;
    };

    const full_feasibility_check = function (lattice, options, number, position) {
        // filters handle the rest, so we just make sure there aren't any numbers left that can't be placed anywhere
        for (let i in options)
            if (options[i].length === 0) return false;

        return true;
    }

    const is_edge = function (pos, edge) {
        switch (edge) {
            case "top":
                return pos < 16;
            case "bottom":
                return pos >= 240;
            case "left":
                return pos % 16 === 0;
            case "right":
                return pos % 16 === 15;
        }
        return false;
    }

    const propagate = function (lattice, options) {
        let changed = true;
        outer:
        while (changed) {
            changed = false;
            // place if a number can only be at one spot
            for (let key = 0; key < 256; key++) {
                const arr = options[key];
                if (arr.length === 1 && lattice[arr[0]] === -1) {
                    const res = place_number_and_prop(lattice, options, key, arr[0]);
                    if (!res.can_place) return { can_place: false };
                    lattice = res.lattice;
                    options = res.options;
                    changed = true;
                    continue outer; // restart scan
                }
            }

            // place if there can only be one number at a spot
            // this should theoretically already be covered by the filters,
            // so this might only prune branches rather than ever place numbers
            for (let key = 0; key < 256; key++) {
                if (lattice[key] !== -1) continue;
                let number = 0;
                let is_boxed = true;

                const ne = lattice[move_at(key, "NE")];
                if (ne === -1) continue;
                number |= ne & 0b00010000 ? 0b00000001 : 0;

                const e = lattice[move_at(key, "E")];
                if (e === -1) continue;
                number |= e & 0b00100000 ? 0b00000010 : 0;

                const se = lattice[move_at(key, "SE")];
                if (se === -1) continue;
                number |= se & 0b01000000 ? 0b00000100 : 0;
                
                const s = lattice[move_at(key, "S")];
                if (s === -1) continue;
                number |= s & 0b10000000 ? 0b00001000 : 0;
                
                const sw = lattice[move_at(key, "SW")];
                if (sw === -1) continue;
                number |= sw & 0b00000001 ? 0b00010000 : 0;
                
                const w = lattice[move_at(key, "W")];
                if (w === -1) continue;
                number |= w & 0b00000010 ? 0b00100000 : 0;
                
                const nw = lattice[move_at(key, "NW")];
                if (nw === -1) continue;
                number |= nw & 0b00000100 ? 0b01000000 : 0;
                
                const n = lattice[move_at(key, "N")];
                if (n === -1) continue;
                number |= n & 0b00001000 ? 0b10000000 : 0;
                
                if (!options[number].includes(key)) return { can_place: false };
                // console.log(number);
                const res = place_number_and_prop(lattice, options, number, key);
                if (!res.can_place) return { can_place: false };
                lattice = res.lattice;
                options = res.options;
                changed = true;
                continue outer;
            }
        }
        return {
            lattice,
            options,
            can_place: true
        };
    }

    // returns whether or not the number can be placed, as well as changed lattice and options
    const place_number_and_prop = function (lattice, options, number, pos) {
        // console.log(number, pos);
        lattice = [...lattice];
        options = options.map(arr => [...arr]);

        // place
        if (!options[number].includes(pos)) return { can_place: false };
        lattice[pos] = number;
        options[number] = [pos];

        // filter search space
        options = filter_search_space(lattice, options, number, pos);

        // check feasibility
        let is_feasible = full_feasibility_check(lattice, options, number, pos);
        if (!is_feasible) return { can_place: false };

        // propagate
        let result = propagate(lattice, options);

        return result;
    }

    // returns whether or not the number can be placed
    const can_place = function (lattice, options, number, pos) {
        if (!options[number].includes(pos)) return false;
        if (lattice[pos] !== -1) return false;
        let ones = 0, zeroes = 0;
        // top left
        if (is_edge(pos, "top") && is_edge(pos, "left")) {
            zeroes |= 0b01000000;
        } else if (!is_edge(pos, "top") && lattice[pos - 17] !== -1 && (lattice[pos - 17] & 0b00000100) !== 0) {
            ones |= 0b01000000;
        }
        // top
        if (is_edge(pos, "top")) {
            zeroes |= 0b10000000;
        } else if (lattice[pos - 16] !== -1 && (lattice[pos - 16] & 0b00001000) !== 0) {
            ones |= 0b10000000;
        }
        // top right
        if (is_edge(pos, "top") && is_edge(pos, "right")) {
            zeroes |= 0b00000001;
        } else if (!is_edge(pos, "top") && lattice[pos - 15] !== -1 && (lattice[pos - 15] & 0b00010000) !== 0) {
            ones |= 0b00000001;
        }
        // right
        if (is_edge(pos, "right")) {
            zeroes |= 0b00000010;
        } else if (lattice[pos + 1] !== -1 && (lattice[pos + 1] & 0b00100000) !== 0) {
            ones |= 0b00000010;
        }
        // bottom right
        if (is_edge(pos, "bottom") && is_edge(pos, "right")) {
            zeroes |= 0b00000100;
        } else if (!is_edge(pos, "bottom") && lattice[pos + 17] !== -1 && (lattice[pos + 17] & 0b01000000) !== 0) {
            ones |= 0b00000100;
        }
        // bottom
        if (is_edge(pos, "bottom")) {
            zeroes |= 0b00001000;
        } else if (lattice[pos + 16] !== -1 && (lattice[pos + 16] & 0b10000000) !== 0) {
            ones |= 0b00001000;
        }
        // bottom left
        if (is_edge(pos, "bottom") && is_edge(pos, "left")) {
            zeroes |= 0b00010000;
        } else if (!is_edge(pos, "bottom") && lattice[pos + 15] !== -1 && (lattice[pos + 15] & 0b00000001) !== 0) {
            ones |= 0b00010000;
        }
        // left
        if (is_edge(pos, "left")) {
            zeroes |= 0b00100000;
        } else if (lattice[pos + 1] !== -1 && (lattice[pos + 1] & 0b00000010) !== 0) {
            ones |= 0b00100000;
        }
        
        if ((number & ones) !== ones || (number & zeroes) !== 0) return false;
        return true;
    }

    // this uses a hybrid approach:
    // both assigning a position to a number and assigning a number to a position are possible
    // we always take the option with the fewest available option, to reduce the branch factor as much as possible
    const select_next_idx = function (lattice, options) {
        let choice_amt = 256;
        let choice = -1;
        let choice_type = "num_to_pos";
        // first we check which number has the fewest available positions
        for (let i in options) {
            if (options[i].length < choice_amt && options[i].length > 1) {
                choice_amt = options[i].length;
                choice = Number(i);
            }
        }

        // second we check if there are positions with fewer available numbers
        for (let key = 0; key < 256; key++) {
            if (lattice[key] !== -1) continue;
            let count = 0;
            for (let num = 0; num < 256; num++) {
                if (can_place(lattice, options, num, key)) count++;
            }
            if (count < choice_amt) {
                choice_amt = count;
                choice = key;
                choice_type = "pos_to_num";
            }
        }

        // console.log(choice, choice_type);


        return { number: choice, type: choice_type };
    }

    const count_placed = function (lattice) {
        let count = 0;
        for (let i of lattice) count += i !== -1;
        return count;
    }

    const back_track = async function (lattice, options, n) {
        const depth = count_placed(lattice);
        if (depth === 256) return lattice;
        if (depth >= max_depth) {
            console.log(depth);
            max_depth = depth;
            draw_lattice(lattice);
            await nextFrame();
        }

        if (n.type === "num_to_pos") {
            const value = n.number;
            for (let i of options[value]) {
                i = Number(i);
                let lattice_loc = [...lattice];
                let options_loc = [...options].map(x => [...x]);
                const result = place_number_and_prop(lattice_loc, options_loc, value, i);
                lattice_loc = result.lattice;
                options_loc = result.options;
                if (result.can_place === false) continue;
                let solution = await back_track(lattice_loc, options_loc, select_next_idx(lattice_loc, options_loc));
                if (solution !== false) return solution;
            }
        } else if (n.type === "pos_to_num") {
            const pos = n.number;
            for (let num = 0; num < options.length; num++) {
                if (!options[num].includes(pos)) continue;
                let lattice_loc = [...lattice];
                let options_loc = [...options].map(x => [...x]);
                const result = place_number_and_prop(lattice_loc, options_loc, num, pos);
                lattice_loc = result.lattice;
                options_loc = result.options;
                if (result.can_place === false) continue;
                let solution = await back_track(lattice_loc, options_loc, select_next_idx(lattice_loc, options_loc));
                if (solution !== false) return solution;
            }
        }
        return false;
    };

    const solve = async function () {
        let lattice = [], options = [];
        for (let i = 0; i < 256; i++) {
            lattice[i] = -1;
            options[i] = [...Array(256).keys()];
        }
        return await back_track(lattice, options, select_next_idx(lattice, options));
    };


    const nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

    let max_depth = 0;
    (async () => {
        const solution = await solve();
        draw_lattice(solution);
        console.log(JSON.stringify(solution));
        console.log("done!");
    })();
</script>