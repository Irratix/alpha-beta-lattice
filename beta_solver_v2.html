<!DOCTYPE html>
<canvas id="c"></canvas>
<script>
    c = document.getElementById("c");
    ctx = c.getContext("2d");
    cell_width = 64;
    c.width = cell_width * 16;
    c.height = cell_width * 16;

    const draw_centers = function(lattice) {
        for (let i = 0; i < 16; i++) {
            for (let j = 0; j <16; j++) {
                ctx.fillStyle = lattice[16 * j + i] !== -1 ? "lime" : "red";
                ctx.beginPath();
                ctx.arc(
                    (i + 0.5) * cell_width, 
                    (j + 0.5) * cell_width, 
                    cell_width / 4,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            }
        }
    }

    const draw_arms = function(lattice) {
        ctx.strokeStyle = "white";
        ctx.lineWidth = cell_width / 16;
        for (let i = 0; i < 16; i++) {
            for (let j = 0; j <16; j++) {
                const num = lattice[i + 16 * j];
                if (num === -1) continue;
                for (let k = 0; k < 8; k++) {
                    ctx.beginPath();
                    ctx.moveTo((i + 0.5) * cell_width, (j + 0.5) * cell_width);
                    if ((num >> k) & 1) {
                        switch (k) {
                            case 0:
                                ctx.lineTo((i + 1) * cell_width, j * cell_width);
                                break;
                            case 1:
                                ctx.lineTo((i + 1) * cell_width, (j + 0.5) * cell_width);
                                break;
                            case 2:
                                ctx.lineTo((i + 1) * cell_width, (j + 1) * cell_width);
                                break;
                            case 3:
                                ctx.lineTo((i + 0.5) * cell_width, (j + 1) * cell_width);
                                break;
                            case 4:
                                ctx.lineTo(i * cell_width, (j + 1) * cell_width);
                                break;
                            case 5:
                                ctx.lineTo(i * cell_width, (j + 0.5) * cell_width);
                                break;
                            case 6:
                                ctx.lineTo(i * cell_width, j * cell_width);
                                break;
                            case 7:
                                ctx.lineTo((i + 0.5) * cell_width, j * cell_width);
                                break;
                        }
                    }
                    ctx.stroke();
                }
            }
        }
    }

    const draw_lattice = function(lattice) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, c.width, c.height);
        draw_arms(lattice);
        draw_centers(lattice);
    }

    const xor = function(a, b) {
        if (a && b) return true;
        if (!a && !b) return true;
        return false;
    }
    
    const initial_filter = function(options) {
        const options_loc = [... options].map(a => [... a]);
        for (let i in options) {
            i = Number(i);
            if (i & 0b11000001) options_loc[i] = options_loc[i].filter(x => x > 15);
            if (i & 0b00000111) options_loc[i] = options_loc[i].filter(x => x % 16 !== 15);
            if (i & 0b00011100) options_loc[i] = options_loc[i].filter(x => x < 240);
            if (i & 0b01110000) options_loc[i] = options_loc[i].filter(x => x % 16 !== 0);
        }
        console.log(options_loc);
        return options_loc;
    }

    const filter_search_space = function(lattice, options, number, position) {
        let options_loc = [... options].map(x => [... x]);

        // first, filter out all options with the same position
        options_loc = options_loc.map((arr, key) => key == number ? arr : arr.filter(i => i != position));

        // second, filter neighbors
        if (position > 15 && position % 16 !== 15)
            options_loc = options_loc.map((arr, key) => !(number & 0b00000001) === !(key & 0b00010000) ? arr : arr.filter(x => x !== position - 15));
        if (position % 16 !== 15)
            options_loc = options_loc.map((arr, key) => !(number & 0b00000010) === !(key & 0b00100000) ? arr : arr.filter(x => x !== position + 1));
        if (position < 240 && position % 16 !== 15)
            options_loc = options_loc.map((arr, key) => !(number & 0b00000100) === !(key & 0b01000000) ? arr : arr.filter(x => x !== position + 17));
        if (position < 240)
            options_loc = options_loc.map((arr, key) => !(number & 0b00001000) === !(key & 0b10000000) ? arr : arr.filter(x => x !== position + 16));
        if (position < 240 && position % 16 !== 0)
            options_loc = options_loc.map((arr, key) => !(number & 0b00010000) === !(key & 0b00000001) ? arr : arr.filter(x => x !== position + 15));
        if (position % 16 !== 0)
            options_loc = options_loc.map((arr, key) => !(number & 0b00100000) === !(key & 0b00000010) ? arr : arr.filter(x => x !== position - 1));
        if (position > 15 && position % 16 !== 0)
            options_loc = options_loc.map((arr, key) => !(number & 0b01000000) === !(key & 0b00000100) ? arr : arr.filter(x => x !== position + 17));
        if (position > 15)
            options_loc = options_loc.map((arr, key) => !(number & 0b10000000) === !(key & 0b00001000) ? arr : arr.filter(x => x !== position + 16));

        // lastly, check for impossibilities
        for (let i in options_loc) {
            i = Number(i);
            if (options_loc[i].length === 0) return false;
        }
        return options_loc;
    };

    const back_track = async function(lattice, options, pos = 255) {
        if (pos === -1) return lattice;

        if (pos <= min_pos) {
            min_pos = pos;
            draw_lattice(lattice);
            await nextFrame();
        }

        for (let i of options[pos]) {
            i = Number(i);
            let lattice_loc = [...lattice];
            let options_loc = [...options].map(x => [... x]);
            lattice_loc[i] = pos;
            options_loc[pos] = [i];
            let filtered = filter_search_space(lattice_loc, options_loc, pos, i);
            if (filtered === false) continue;
            let solution = await back_track(lattice_loc, filtered, pos - 1);
            if (solution !== false) return solution;
        }
        return false;
    };


    const solve = async function() {
        let lattice = [], options = [];
        for (let i = 0; i < 256; i++) {
            lattice[i] = -1;
            options[i] = [];
            for (let j = 0; j < 256; j++) options[i].push(j);
        }
        options = initial_filter(options);
        return await back_track(lattice, options);
    };


    const nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

    let min_pos = 256;
    (async () => {
        const solution = await solve();
        draw_lattice(solution);
        console.log(solution);
        console.log(min_pos);
        console.log("done!");
    })();
</script>